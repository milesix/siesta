This version of SIESTA contains a new implementation of the legacy
order-N methods based on the Orbital Minimization Method, leveraging the
omm-bundle (containing the libOMM and MatrixSwitch libraries), and the DBCSR library
for sparse matrix multiplication.

Installation notes
------------------

1. Install dbcsr-1.0.0 version:

   - Clone https://github.com/cp2k/dbcsr
   - Checkout the 1.0.0 version:  git checkout v1.0.0
        [The ExtLibs/dbcsr submodule is already set up for this]

   - Remove -fopenmp flags from Makefile.inc. 
   - Add GNU=0 if Intel compiler is used. 
   - Provide paths to external linear algebra libraries using LIBS += (for libraries) 
     and FCFLAGS += (for headers)
 
2. Install omm-bundle from the omm_sparse branch of

           https://gitlab.com/irina_lebedeva/omm-bundle

   [The ExtLibs/omm-bundle submodule is already set up for this]
	   
   following the installation instructions given in INSTALL.

3. Install this Siesta version adding the following lines to arch.make:

OMMPATH = <path to omm-bundle installation directory>
MSPATH = $(OMMPATH)/build_MatrixSwitch
MSLIB = -L$(MSPATH)/lib -lMatrixSwitch
MSINC = -I$(MSPATH)/include

PSPPATH = $(OMMPATH)/build_pspBLAS
PSPLIB = -L$(PSPPATH)/lib -lpspBLAS
PSPINC = -I$(PSPPATH)/include

OMMLIBPATH = $(OMMPATH)/build_libOMM
OMMLIB = -L$(OMMLIBPATH)/lib -lOMM
OMMINC = -I$(OMMLIBPATH)/include

DBCSR     = <path to dbcsr-1.0.0 installation directory>
DBCSRINC  = -I$(DBCSR)/install/include
DBCSRLIB  = -L$(DBCSR)/install/lib -ldbcsr

LIBS += $(OMMLIB) $(MSLIB) $(DBCSRLIB) $(PSPLIB)
INCFLAGS += $(OMMINC) $(MSINC) $(DBCSRINC) $(PSPINC)


Execution
---------

Examples of the input files can be found in Tests/h2o_blomm, Tests/h2o_libomm and Examples/OMM_methods.


Input parameters for OMM routines with libOMM library
-----------------------------------------------------

SolutionMethod
  BLOMM for linear-scaling calculations (functionals of Ordejon-Mauri or Kim)
  LIBOMM for cubic-scaling calculations (OMM)

OMM.LongOutput true (logical)
  Specifies whether to provide in the detailed information on conjugate gradient 
  minimization at each SCF step in libOMM.log.

OMM.ReadCoeffs false (logical)
  Specifies whether to read the coefficients of Localized Wave Functions (LWFs) from the restart 
  files (*.WF_COEFFS_LIBOMM for SolutionMethod LIBOMM or *.WF_COEFFS_BLOMM and 
   *.WF_COEFFS_BLOMM_DATA for SolutionMethod BLOMM) at the beginning of the calculation.
  It is not required that the parameters of the new calculation (e.g. BlockSize, OMM.BlockSizeC,
  parallelization scheme) are the same as of the one used to generate the restart files.
  It is, however, required that the number of LWFs included in the calculation is the same.
  For this reason, for example, it is not possible to switch between Ordejon-Mauri and Kim methods.   
  If the files are not found, a random initial guess is used. It is also recommended to use
  the restart file for the density matrix by setting DM.UseSaveDM true.

OMM.WriteCoeffs false (logical)
  Specifies whether to write the coefficients of LWFs at the beginning of the calculation and
  at each MD step.

OMM.RelTol 10^{-9} for SolutionMethod LIBOMM (real)
           10^{-7} for SolutionMethod BLOMM  (real)
  Relative tolerance for Kohn-Sham band energy in conjugate gradient minimization. 
  Equivalent to ON.Etol. 

OMM.GTol 10^{-3} (real)
  Maximal norm of the gradient in conjugate gradient minimization required for convergence.

OMM.Use2D true (logical)
  Specifies whether to use 2D decomposition of matrices for parallel calculations.

OMM.Extrapolate false (logical)
  Specifies whether to estimate LWFs for the next MD step by linear extrapolation based on the
  results of two previous MD steps. If false, the same LWFs as obtained at the previous step are
  used for the initial guess. In the case of SolutionMethod BLOMM, the change in the sparsity
  pattern is taken into account and corresponding LWF coefficients are set to zero.

OMM.Eta 0.0 Ry (energy)
  Fermi level parameter for the funcitonal of Kim et al. It should be within the energy gap 
  and tuned to obtain the correct number of electrons. The parameter can be estimated, 
  for example, from the previous diagonalization run.

OMM.RcLWF 9.5 Bohr (length)
  Localization radius for LWFs. Only applicable for SolutionMethod BLOMM.

OMM.BlockSizeC (BlockSize * wf_dim)/h_dim (integer)
  The blocksize for LWFs. It is recommended to use the value that corresponds to BlockSize multiplied
  by the total number of LWFs wf_dim and divided by the total number of basis functions h_dim.

OMM.UseCholesky false (logical)
  Specifies whether to perform Cholesky factorization of the generalized eigenvalue problem. 
  This removes the overlap matrix from the problem but also destroys the sparsity of the Hamiltonian.
  Only applicable for SolutionMethod LIBOMM in the case when OMM.Eta is set to 0.

OMM.Precon -1 (integer)
  The number of SCF steps for all MD steps for which to apply a preconditioning scheme based on
  the overlap and kinetic energy matrices. For negative values, preconditioning is applied always.
  Cannot be used with OMM.UseCholesky true. Only applicable for SolutionMethod LIBOMM.

OMM.PreconFirstStep -1 (integer)
  The number of SCF steps of the first MD step for which to apply the preconditioning scheme.
  If present, this will overwrite the value of OMM.Precon for the first MD step.
  Only applicable for SolutionMethod LIBOMM.

OMM.TPreconScale 10 Ry (energy)
  The scale for kinetic energy preconditioning. Only applicable for SolutionMethod LIBOMM.

OMM.NumLWFs N_occ (integer)
  The number of LWFs in calculations with SolutionMethod LIBOMM. By default, equals the number
  of occupied states. Hovewer, can be increased to use in conjunction with OMM.Eta set at Fermi level 
  similar to the functional of Kim et al.
