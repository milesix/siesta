
%! program = pdflatex

\documentclass[12pt]{article}
\usepackage{geometry} % see geometry.pdf on how to lay out the page. There's lots.
\geometry{a4paper} % or letter or a5paper or ... etc
% \geometry{landscape} % rotated page geometry
% See the ``Article customise'' template for come common customisations

%% LaTeX Preamble - Common packages

\usepackage[utf8]{inputenc} % Any characters can be typed directly from the keyboard, eg éçñ
\usepackage{textcomp} % provide lots of new symbols
\usepackage{graphicx}  % Add graphics capabilities
%\usepackage{epstopdf} % to include .eps graphics files with pdfLaTeX
\usepackage{flafter}  % Don't place floats before their definition
%\usepackage{topcapt}   % Define \topcation for placing captions above tables (not in gwTeX)
\usepackage{natbib} % use author/date bibliographic citations

\usepackage{amsmath,amssymb}  % Better maths support & more symbols
\usepackage{bm}  % Define \bm{} to use bold math fonts

\usepackage[pdftex,bookmarks,colorlinks,breaklinks]{hyperref}  % PDF hyperlinks, with coloured links
%\definecolor{dullmagenta}{rgb}{0.4,0,0.4}   % #660066
%\definecolor{darkblue}{rgb}{0,0,0.4}
\hypersetup{linkcolor=red,citecolor=blue,filecolor=dullmagenta,urlcolor=darkblue} % coloured links
%\hypersetup{linkcolor=black,citecolor=black,filecolor=black,urlcolor=black} % black links, for printed output

\usepackage{memhfixc}  % remove conflict between the memoir class & hyperref
% \usepackage[activate]{pdfcprot}  % Turn on margin kerning (not in gwTeX)
\usepackage{pdfsync}  % enable tex source and pdf output syncronicity

\title{Developer guide of the atomic part of SIESTA}
\author{Eduardo Anglada}


%%% BEGIN DOCUMENT
\begin{document}

\maketitle
\tableofcontents

\section{Introduction}
This guide should be used by a developer who wants to understand how the atomic part of siesta is constructed and used. It should be useful for someone who wants to add a new kind of radial function (a new kind of projector, ...), modify the atomic orbitals or add anything related to the atomic part of siesta.

\section{How to ...}

\subsection{Use the radial functions}

All of the radial functions used by siesta must be strictly confined in real space. The radial functions should be defined in a linear grid, which is described in \verb+radial_lin.F90+. But all the functions generated by the pseudo program are stored in a logarithmic grid (see \verb+radial_log.F90+), so during the generation of the atomic information (orbs, KBs, etc) we use functions defined in a logarithmic grid and at the end we convert them into a linear one.  There is a high level interface to the radial functions (\verb+radial.F90+) which identifies the kind of grid and calls the appropriate function. If you add a new function it should be defined in the file corresponding to the grid kind (\verb+ radial_lin.F90 radial_log.F90+) and in \verb+radial.F90+. In all of these files there are functions which can be used as templates for your new implementations.

\subsection{Storage of the radial functions}
Appart from the function itself we need to store other quantities related with the function: energy, occupation, etc. So there is a data type which associates the radial functions with this quantities: the \verb+hilbert_vector+ (this name is misliding, we should find another one which is easier to understand!). It's defined in \verb|hilbert_vector_collection.f90|. The structure of this data type is: 

\begin{verbatim}
type hilbert_vector_t
   private
   type(rad_func_t), pointer     :: rad_func =>Null() !the radial function
   integer                       :: l,n !quantum numbers
   real(dp)                      :: energy !energy
   real(dp)                      :: pop !population
   integer                       :: zeta !index
   logical                       :: pol !If it's a polarization orbital.
end type hilbert_vector_t
\end{verbatim}

As there are several copies of the same function with different quantum numbers (same l, different m)
we need an efficient (not memory hungry) storage:  \verb+hilbert_vector_collection_t+ (see \verb+hilbert_vector_collection.F90+):

\begin{verbatim}

type hilbert_vector_collection_t
     private
     !Data structure which contains a collection of rad_funcs
     !of the same type (orbitals, kb_proj, lda+u_proj, ...)
     !and the list of degenerate copies (those who share the
     !same l but a different m).
     integer                         ::  lmax ! l max
      
     !Aggregate numbers of orbitals and projectors (including 2l+1
     !        copies for each "nl"), and index arrays keeping track of
     !        which "nl" family they belong to, and their n, l, and m (to avoid
     !        a further dereference)

     integer                         ::  n_funcs = -1! num of funcs including 2l+1 copies.

     integer, pointer, dimension(:)  ::  m => Null() ! m of each nl funcs
     integer, pointer, dimension(:)  ::  index => Null() !Used to identify the nl the function belong.
    
     !The orbitals/projectors themselves (ie the "nl" in the old format):
     type(hilbert_vector_t), dimension(:), pointer :: vec => Null()
     
  end type hilbert_vector_collection_t
  
\end{verbatim}

So the information is stored in a layered structure. A top down view is:

\verb+hilbert_vector_collection-> hilbert_vector -> radial+

A function of a given layer can call a function of a lower layer or another function
of the same layer, but not a function at a higher layer.

\subsection{Memory usage: when to alloc/dealloc }
All the functions of a given layer return an instance of a type defined at that layer or
a lower one, and you are responsible for releasing them when you don't need it anymore.
Example:

\begin{verbatim}
type(rad_func_t) :: my_orb, modified_orb
type(hilbert_vector_t):: vector

my_orb = rad_schro(potential,l,...)
modified_orb=rad_modify(my_orb)

!Store the orb in a hilbert_vector

vector = hilbert_vector_init(modified_orb, l, ...)

!Store the basis, explained later.

!At the end you must release the memory:

call rad_dealloc(my_orb)
call rad_dealloc( modified_orb)
call rad_dealloc(vector)
\end{verbatim}


\subsection{Howto store/retrieve all the information of a given species}
All the information of a given species is stored in another data type \verb|species_info_t| (see
\verb|atom_types.F90|).

\begin{verbatim}
  type species_info_t     private     logical                                    ::  fake = .false. !real species or not     character(len=symbol_length)               ::  symbol     character(len=label_length)                ::  label     real(dp)                                   ::  atomic_number               real(dp)                                   ::  mass     real(dp)                                   ::  valence_charge        real(dp)                                   ::  self_energy !Electrostatic     type(rad_func_t), pointer                  ::  reduced_vlocal => Null()     type(rad_func_t), pointer                  ::  neutral_atom_potential  => Null()     type(rad_func_t), pointer                  ::  pseudo_local_charge  => Null()     !Core charge for nonlinear core corrections     type(rad_func_t), pointer                  ::  core_charge  => Null()     logical                                         ::  has_core_charge           type(hilbert_vector_collection_t)          ::  orbs     type(hilbert_vector_collection_t), pointer ::  kb_proj, ldau_proj  => Null()     logical                                    ::  read_from_file  end type species_info_t
\end{verbatim}

In \verb|atom_types.F90| you can find all the interface functions which access the contents of 
\verb!species_info_t! (all the atomic information of a given species) and the subroutine which broadcasts this information to all the nodes during a parallel run. In this data
type you have to add the new \verb!hilbert_vector_collection! corresponding to the functions which retrieve their values.

Now we will see how to add a new kind of function and its interface in \verb+atom_types.f90+
Each kind of radial function is identified using a data type which holds and integer! This helps the compiler, because it can check if the argument of a function makes sense. 
This  integer is stored in a data type (\verb!func_t!) which is defined in \verb!atmfuncs_types.f90!: 

\begin{verbatim}
  type, public :: func_t
     private
     integer     :: func_type = 0 !This integer identifies the kind of radial function
  end type func_t

  type(func_t), parameter, public ::  &
       orb_f     = func_t(1) , &
       kbpj_f    = func_t(2) , &
       vlocal_f  = func_t(3), &
       vna_f     = func_t(4), &
       chlocal_f = func_t(5), &
       core_f    = func_t(6)
\end{verbatim}

So if you want to add a new kind of radial function you should:

\begin{enumerate}
\item Include the new radial kind in the previous data type with an integer which has not been used before. 
\item Include the corresponding \verb!hilbert_vector_collection_t! in \verb!species_info_t!, and the functions which retrieve data from it. % (\verb!get_new_kind_l! in the following example). 

\item Expand the functions in atmfuncs.f90, because they need to know how to identify the new kind  and call the function which retrieves its formation.
%Once the atomic information has been generated and \verb!stored in species_info_t! it should be made accessible for the other parts of Siesta using the functions in \verb+atmfuncs.f90+.  So for example, if you want to expand the function which retrieves the l quantum number of a given function you have to use lofio:  
\end{enumerate}

As an example suppose that you want to add a new kind called: foo. In \verb!func_t! we add
the new integer:

\begin{verbatim}
type(func_t), parameter, public ::  &
       orb_f     = func_t(1) , &
       kbpj_f    = func_t(2) , &
       vlocal_f  = func_t(3), &
       vna_f     = func_t(4), &
       chlocal_f = func_t(5), &
       core_f    = func_t(6), &
       foo_f     = func_t(7) 
\end{verbatim}

In \verb!atmfuncs.f90! we expand all the subroutines.  For example the one which asks which is the l quantum number  is called \verb!lofio!: 

\begin{verbatim}
 FUNCTION lofio (IS,func,io)    integer lofio    integer, intent(in)            :: is    ! Species index    type(func_t), intent(in)   :: func  !Func label    integer, intent(in)           :: io    ! Function index (within specie)
 if (func==orb_f) then       if (io.gt. get_number_of_orbs(spp)) call die("lofio: No such orbital")       lofio = get_orb_l(spp,io)    else if (func==kbpj_f) then       if (io.gt. get_number_of_kb_projs(spp)) call die("lofio: No such projector")       lofio = get_kb_proj_l(spp,io)    else       lofio = 0    endif
endif
\end{verbatim}

We include a new \verb!else if! which identifies the new kind of function:

\begin{verbatim}
 elseif(func == foo_f)then
        lofio = get_foo_l(spp,io)
 \end{verbatim}

We are done!
 
Remember: 
\begin{itemize}
\item The new functions equivalents to \verb!get_foo_l! should be added in \verb!atom_types.F90! 
\item  Almost all the functions in \verb!atmfuncs.f90! should be expanded including the call to the new
functions.
\end{itemize}

\subsection{A more (or less) complete example}

\begin{verbatim}
type(rad_func_t) :: my_orb, modified_orb
type(hilbert_vector_t):: vector

my_orb = rad_schro(potential,l,...)
modified_orb=rad_modify(my_orb)

!Store the orb in a hilbert_vector

vector = hilbert_vector_init(modified_orb, l, ...)

call set_basis(spp,vector, ...)

!Remember you must release the memory:

call rad_dealloc(my_orb)
call rad_dealloc( modified_orb)
call destroy_vector(vector)
\end{verbatim}

\subsection{Step by step explanation of the generation procedure}

The previous example omits a crucial point: where do I include such
code?
This section details the procedure:

\begin{enumerate}
\item \verb!Siesta_init! calls
\item \verb!generate_all_atomic_info! (see \verb!atom.f90!)
Which:
     \begin{enumerate}
     \item Reads the basis from files (if the user requested it).
     \item Reads the basis specs (reading the fdf and using the default heuristics).
     \item Generates the species information (\verb!atom_main! in atom.f90): orbs, kbs, vna.
     \item Filters all of them.
     \item Computes the tables with the electrostatic correction. 
     \item Dumps the basis (if the user requested it).
     \end{enumerate}
\end{enumerate}

As you can imagine the subroutine \verb!atom_main!  is really interesting:

\begin{verbatim}
   if (basis_parameters(isp)%bessel .or. basis_parameters(isp)%floating) floating = .true.   
    call species_init(isp,floating)       if (basis_parameters(isp)%bessel) then       call set_has_core_charge(species(isp), .false.)       call bessel(isp)    elseif (basis_parameters(isp)%floating) then       call species_pseudopotential_init(isp)       call species_charge(isp)       call basis_gen(isp)    else !Standard basis       call species_pseudopotential_init(isp)       call species_charge(isp)              call gen_vlocal(isp)       call kbgen(isp)       call basis_gen(isp)    endif    write(6,'(/,a)') 'ATOM: Species end_____________________________ '
\end{verbatim}

You have to decide which of the above functions you would like to modify or where to plug your new function.
In the previous snip of code you can see that the decisions are taken reading the contents
of the \verb!basis_paramaters! structure. This structure holds the input (filled with the fdf or heuristics). It can be found in file:  \verb!atm_generation_types.f90! The parsing of the input is done in \verb!basis_specs.f90!

\section{Comments}
\begin{itemize}
\item The hilbert vector name is misleading. (rad_atom?, atomic_rad_func?)
\item Maybe there are too many layers.
\item Some vars are duplicated: they are copied from \verb!basis_specs! directly to \verb!species_info_t! 
\item Add yours here
\end{itemize}
\end{document}

